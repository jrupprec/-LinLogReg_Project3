---
title: "Project 3"
author: "Vilgot Hillbom, Jens Rupprecht"
format: beamer
pdf-engine: pdflatex
editor: visual
execute:
  echo: false
  warning: false
  output: true
---

## Preparing the data

```{r}
library(ggplot2)
library(pscl)
library(dplyr)
# Necessary for ordinal regression:
library(MASS)
# Necessary for multinomial regression:
library(nnet)
weather <- read.csv("/Users/vilgot/Documents/Plugg/linlog/Projects R/LinLogReg_Project1/weather.csv", sep = ",", dec = ".")
#weather <- read.csv("~/weather.csv", sep = ",", dec = ".")

#weather[weather$location == "KatterjÃ¥kk",]$location <- "Katterjokk"
weather[weather$location == "Katterjåkk",]$location <- "Katterjokk"

g <- 3
weather$group <- as.character(cut(weather$rain, breaks = g))
weather$group[weather$group == "(-0.0918,97.5]"] <- "low precipitation"
weather$group[weather$group == "(97.5,195]"] <- "medium precipitation"
weather$group[weather$group == "(195,292]"] <- "high precipitation"
weather$group <- as.factor(weather$group)

weather$eq.group <- as.character(cut(weather$rain,
                        breaks = quantile(weather$rain, probs = seq(0,g)/g),
                        include.lowest = TRUE))
weather$eq.group[weather$eq.group == "[0.2,39.7]"] <- "low precipitation"
weather$eq.group[weather$eq.group == "(39.7,68.4]"] <- "medium precipitation"
weather$eq.group[weather$eq.group == "(68.4,292]"] <- "high precipitation"
weather$eq.group <- as.factor(weather$eq.group)

weather$monthnr <- as.factor(substr(weather$month, 6, 7))
```

## Model selection for the equally sized group
```{r}
# here we construct the null and the full model
model.null <- polr(eq.group ~ 1, data=weather)
model.full <- polr(eq.group ~ pressure + location + speed + temp + monthnr, data = weather)
# n = number of observations
n <- nrow(weather)

Model.olog.Fw <- step(model.null, # start with the minModel instead of nullModel
                direction = 'forward', # run forward selection
                scope = list(upper = model.full, # the maximum to consider is a model with all variables
                             lower = model.null), # the minimum to consider is a model with X10 only
               trace = 0, k=log(n))

Model.olog.Bw <- step(model.full, # start with the minModel instead of nullModel
                direction = 'backward', # run forward selection
                scope = list(upper = model.full, # the maximum to consider is a model with all variables
                            lower = model.null), # the minimum to consider is a model with X10 only
                trace = 0, k=log(n))

(model.final <- step(model.full))
(sum.final <- summary(model.final))

bic.olog.Fw <- BIC(Model.olog.Fw)
aic.olog.Fw <- AIC(Model.olog.Fw)
mcf2.olog.Fw <- pR2(Model.olog.Fw)['McFadden']


bic.olog.Bw <- BIC(Model.olog.Bw)
aic.olog.Bw <- AIC(Model.olog.Bw)
mcf2.olog.Bw <- pR2(Model.olog.Bw)['McFadden']

bic.olog.final <- BIC(model.final)
aic.olog.final <- AIC(model.final)
mcf2.olog.final <- pR2(model.final)['McFadden']

comparison <- data.frame(BIC = c(bic.olog.Fw, bic.olog.Bw, bic.olog.final),
                            AIC = c(aic.olog.Fw, aic.olog.Bw, aic.olog.final),
                            McFadden = c(mcf2.olog.Fw,mcf2.olog.Bw, mcf2.olog.final))
```




```{r compbw, results='asis'}
kableExtra::kable(comparison, format = "latex",  caption = "Comparison of Model Selection Process for equally sized groups") %>% kableExtra::kable_styling(full_width = F, position="center", latex_options="HOLD_position")
```



```{r}
#Parameter estimates####
##beta-estimates####
cbind(beta = model.final$coefficients, 
      expbeta = exp(model.final$coefficients),
      exp(confint(model.final)))
##zeta-extimates####
cbind(zeta = model.final$zeta, 
      expzeta = exp(model.final$zeta))

## beta and zeta with s.e.####
sum.final$coefficients

#Odds####
## Odds for unlikely, all x=0####
exp(model.final$zeta[1])
## Odds for unlikely, pared = 1####
exp(model.final$zeta[1])/exp(model.final$coefficients[1])
## Odds for unlikely, pared = 1 and gpa = 3####
exp(model.final$zeta[1])/exp(model.final$coefficients[1] + 3*model.final$coefficients[2])

#Estimate props and categories####
##estimated probabilities####
predict(model.final, type = "prob")
##predicted category####
predict(model.final)
predict(model.final, type = "class")

#AIC, BIC, R2####
## deviance####
model.final$deviance
## total number of parameters (beta and zeta)####
model.final$edf
##collect measures####
info <- cbind(aic = AIC(model.null, model.final, model.full),
              bic = BIC(model.null, model.final, model.full),
              R2D = 100*c(1 - model.null$deviance/model.null$deviance, 
                          1 - model.final$deviance/model.null$deviance, 
                          1 - model.full$deviance/model.null$deviance),
              R2D.adj = 100*c(1 - (model.null$deviance + model.null$edf - model.null$edf)/
                                model.null$deviance, 
                              1 - (model.final$deviance + model.final$edf - model.null$edf)/
                                model.null$deviance, 
                              1 - (model.full$deviance + model.full$edf - model.null$edf)/
                                model.null$deviance))
round(info, digits = 1)

# LR-test comparing nested models####
anova(model.null, model.final)
anova(model.final, model.full)

#Goodness-of-fit####
##Confusion matrix####

pred.final <- cbind(weather,
                    yhat = predict(model.final))
(conf.matrix <- table(pred.final$eq.group, pred.final$yhat))
table(pred.final$eq.group)
table(pred.final$yhat)
sum(conf.matrix)

##Sensitivity etc####
(sens <- 100*(diag(conf.matrix)/table(pred.final$eq.group)))
(prec <- 100*(diag(conf.matrix)/table(pred.final$yhat)))
(acc <- 100*sum(diag(conf.matrix)/sum(conf.matrix)))

```
## Visualization of Quantity of Interest (Pressure, Location)

```{r}
#Predict and ...####
x0 <- data.frame(pressure = rep(seq(980,1035,5),3),
                 location = c(rep("Lund", length(seq(980,1035,5))),
                              rep("Uppsala", length(seq(980,1035,5))),
                              rep("Katterjokk", length(seq(980,1035,5)))))
                 
  
  
  #gpa = rep(seq(2, 4, 0.1), 2),
  #               pared = c(rep("no", length(seq(2, 4, 0.1))),
  #                         rep("yes", length(seq(2, 4, 0.1)))))

model.final <- polr(eq.group ~ pressure + location , data = weather)

pred.final <- cbind(
  x0,
  predict(model.final, newdata = x0, type = "prob"),
  yhat = predict(model.final, newdata = x0))

##plot probs####
ggplot(pred.final, aes(x = pressure)) +
  geom_line(aes(y = `low precipitation`, color = "low precipitation"), linewidth = 2) +
  geom_line(aes(y = `medium precipitation`, color = "medium precipitation"), linewidth = 2) +
  geom_line(aes(y = `high precipitation`, color = "high precipitation"), linewidth = 2) +
  labs(color = "apply", title = "Which percipitation?") +
  facet_wrap(~ location, labeller = "label_both") +
  theme(text = element_text(size = 14))
```

## Stacked Visualization
```{r}
##plot stacked probs####
ggplot(pred.final, aes(x = pressure)) +
  geom_ribbon(aes(ymin = 0, ymax = `low precipitation`, fill = "low precipitation")) +
  geom_ribbon(aes(ymin = `low precipitation`, 
                  ymax = `low precipitation` + `medium precipitation`, 
                  fill = "medium precipitation")) +
  geom_ribbon(aes(ymin = `low precipitation` + `medium precipitation`, ymax = 1,
                  fill = "high precipitation")) +
  labs(fill = "apply", title = "Which percipitation?") +
  facet_wrap(~ location, labeller = "label_both") +
  theme(text = element_text(size = 14))
```


## Visualization of Quantity of Interest (Speed, Location)

```{r}
#Predict and ...####
x0 <- data.frame(speed = rep(seq(1,9,0.5),3),
                 location = c(rep("Lund", length(seq(1,9,0.5))),
                              rep("Uppsala", length(seq(1,9,0.5))),
                              rep("Katterjokk", length(seq(1,9,0.5)))))
                 
  
  
  #gpa = rep(seq(2, 4, 0.1), 2),
  #               pared = c(rep("no", length(seq(2, 4, 0.1))),
  #                         rep("yes", length(seq(2, 4, 0.1)))))

model.final <- polr(eq.group ~ speed + location , data = weather)

pred.final <- cbind(
  x0,
  predict(model.final, newdata = x0, type = "prob"),
  yhat = predict(model.final, newdata = x0))

##plot probs####
ggplot(pred.final, aes(x = speed)) +
  geom_line(aes(y = `low precipitation`, color = "low precipitation"), linewidth = 2) +
  geom_line(aes(y = `medium precipitation`, color = "medium precipitation"), linewidth = 2) +
  geom_line(aes(y = `high precipitation`, color = "high precipitation"), linewidth = 2) +
  labs(color = "apply", title = "Which percipitation?") +
  facet_wrap(~ location, labeller = "label_both") +
  theme(text = element_text(size = 14))
```

## Stacked Visualization
```{r}
##plot stacked probs####
ggplot(pred.final, aes(x = speed)) +
  geom_ribbon(aes(ymin = 0, ymax = `low precipitation`, fill = "low precipitation")) +
  geom_ribbon(aes(ymin = `low precipitation`, 
                  ymax = `low precipitation` + `medium precipitation`, 
                  fill = "medium precipitation")) +
  geom_ribbon(aes(ymin = `low precipitation` + `medium precipitation`, ymax = 1,
                  fill = "high precipitation")) +
  labs(fill = "apply", title = "Which percipitation?") +
  facet_wrap(~ location, labeller = "label_both") +
  theme(text = element_text(size = 14))
```






## Multinomial
```{r}
weather$group <- relevel(weather$eq.group, ref = "low precipitation")


#creating null model
(model.null <- multinom(eq.group ~ 1, data = weather))
(sum.null <- summary(model.null))

#
(model.pressure <- multinom(eq.group ~ pressure, data = weather))
(model.speed <- multinom(eq.group ~ speed, data = weather))
(sum.math <- summary(model.pressure))

(model.full <- multinom(eq.group ~ pressure + speed + temp + monthnr
                          , data = weather))

model.final <- step(model.null,
                     scope = list(upper = model.full, lower = model.null),
                     direction = "both",
                  k = log(nrow(weather)))



```
```{r}
sum.final <- summary(model.final)
sum.final

#odds
(beta <- sum.final$coefficients)
(se.beta <- sum.final$standard.errors)
(z.value <- beta/se.beta)
(P.value <- pnorm(abs(z.value), lower.tail = FALSE))

#odds ratios####
(OR <- exp(beta))
OR
OR["low precipitation", ]
OR["medium precipitation", ]

## Confidence intervals for OR####
ci <- exp(confint(model.final))
# a 3-dimensional matrix!
ci

```
```{r}

```

